{
    "collab_server" : "",
    "contents" : "#' Takes a vector of paths to input files and aligns common metabolites into a final table.  Will also identify metabolites if a reference library is provided\n\n#' @param inputFileList Vector of file paths to align\n#' @param RT1_Standards Vector of standard names used to adjust first retention time. All names must be found in input files. Set to c() to avoid using RT adjustment. Defaults to FAME_8-24.\n#' @param RT2_Standards Vector of standard names used to adjust second retention time. All names must be found in input files. Set to c() to avoid using RT adjustment. Defaults to empty vector.\n#' @param seedFile File number in inputFileList to initialize alignment. Can also input a vector of different seed files (3 is usually sufficient) to prevent bias from seed file.  Defaults to 1.\n#' @param RT1Penalty Penalty used for first retention time errors.  Defaults to 1.\n#' @param RT2Penalty Penalty used for first retention time errors.  Defaults to 10.\n#' @param autoTuneMatchStringency Will automatically find optimal match threshold. If TRUE, will ignore similarityCutoff. Defaults to TRUE.\n#' @param similarityCutoff Adjusts peak similarity threshold required for alignment. Adjust in concordance with RT1 and RT2 penalties. Will be ignored if autoTuneMatchStrigency is TRUE. Defaults to 90.\n#' @param disimilarityCutoff Defaults to similarityCutoff-90. Sets the threshold for including a new peak in the alignment table to ensure new metabolites aren't just below alignment thresholds\n#' @param numCores Number of cores used to parallelize alignment. See parallel package. Defaults to 4.\n#' @param commonIons Provide a vector of ions to ignore from the FindProblemIons function. Defaults to empty vector.\n#' @param missingValueLimit Maximum fraction (Numeric between 0 and 1) of missing values acceptable for retaining a metabolite in the final alignment table. Defaults to 0.25.\n#' @param missingPeakFinderSimilarityLax Fraction of Similarity Cutoff to use to find missing alignments just below threshold. Set to 1 to prevent searching for missing peaks. Defaults to 0.85.\n#' @param quantMethod Set to U, A, or T to indicate if unique mass (U), appexing masses (A), or total ion chormatograph (T) was used to quantify peak areas. Defaults to T.  If \"T\" or \"A\", peaks meeting similarity thresholds will simply be summed. If \"U\", peaks with the same unique mass with be summed and a proportional conversion will be used before combining peaks with different unique masses.\n#' @param standardLibrary Defaults to NULL. Provide standard library generated from MakeReference function to ID metabolites with retention index.\n\n#' @return A list with three items: AlignmentMatix - A dataframe with peak areas for all metabolites matched in sufficient number of samples. MetaboliteInfo - An info file with RT, spectra, and metabolite ID info for each metabolite in the AlignmentMatrix. UnmatchedQuantMasses- Info on metabolites combined that had different unique masses (if quantMethod=\"U\") or greater than 50% different apexing masses (if quantMethod=\"A\")\n#' @import parallel\n#' @export\n#' @examples\n#' ConsensusAlign(c(system.file(\"extdata\", \"SampleA.txt\", package=\"R2DGC\"),\n#'     system.file(\"extdata\", \"SampleB.txt\", package=\"R2DGC\")), RT1_Standards= c())\n\nConsensusAlign<-function(inputFileList,\n                         RT1_Standards=paste(\"FAME_\", seq(8,24,2), sep=\"\"),\n                         RT2_Standards=c(),\n                         seedFile=1, #Change to 5 for test case reproducibility\n                         RT1Penalty=1,\n                         RT2Penalty=10, #1 for relatively unstable spectras\n                         autoTuneMatchStringency=TRUE,\n                         similarityCutoff=90,\n                         disimilarityCutoff=similarityCutoff-90,\n                         numCores=1,\n                         commonIons=c(),\n                         missingValueLimit=0.75,\n                         missingPeakFinderSimilarityLax=0.85,\n                         quantMethod=\"T\",\n                         standardLibrary=NULL){\n  require(parallel)\n\n  AlignmentTableList<-list()\n  for(seed in seedFile){\n    message(paste(seed, \"seed\"))\n    #Read in and format seed file\n    seedRawFile<-read.table(inputFileList[seed], sep=\"\\t\", fill=T, quote=\"\",strip.white = T, stringsAsFactors = F,header=T)\n    seedRawFile[,4]<-as.character(seedRawFile[,4])\n    seedRawFile<-seedRawFile[which(!is.na(seedRawFile[,3])&nchar(seedRawFile[,4])!=0),]\n    seedRawFile[,2]<-as.character(seedRawFile[,2])\n\n    #Parse seed file retention time\n    RTSplit<-data.frame(strsplit(seedRawFile[,2], \" , \"), stringsAsFactors = F)\n    RTSplit[1,]<-gsub(\"\\\"\", \"\", RTSplit[1,])\n    RTSplit[2,]<-gsub(\"\\\"\", \"\", RTSplit[2,])\n    seedRawFile[,\"RT1\"]<-as.numeric(t(RTSplit[1,]))\n    seedRawFile[,\"RT2\"]<-as.numeric(t(RTSplit[2,]))\n\n    #Index metabolites by RT1 Standards\n    if(length(RT1_Standards)>0){\n\n      #Check if all RT1 standards are present in each file\n      if(sum(RT1_Standards%in%seedRawFile[,1])!=length(RT1_Standards)){\n        message(paste(\"Seed file missing RT1 standards:\",RT1_Standards[which(!RT1_Standards%in%seedRawFile[,1])],sep=\" \"))\n        break\n      }\n\n      #Index each metabolite by RT1 Standards\n      RT1_Length<-max(seedRawFile[which(seedRawFile[,1]%in%RT1_Standards),6])-min(seedRawFile[which(seedRawFile[,1]%in%RT1_Standards),6])\n      for(Standard in RT1_Standards){\n        seedRawFile[,paste(Standard,\"RT1\",sep=\"_\")]<-(seedRawFile[,6]-seedRawFile[grep(Standard,seedRawFile[,1],perl = T),6])/RT1_Length\n      }\n    }\n\n    #Index metabolites by RT2 Standards\n    if(length(RT2_Standards)>0){\n\n      #Check if all RT2_Standards are present\n      if(sum(RT2_Standards%in%seedRawFile[,1])!=length(RT2_Standards)){\n        message(paste(\"Seed file missing RT2 standards:\",RT2_Standards[which(!RT2_Standards%in%seedRawFile[,1])],sep=\" \"))\n        break\n      }\n\n      #Index each metabolite by RT2 standards\n      RT2_Length<-max(seedRawFile[which(seedRawFile[,1]%in%RT2_Standards),6])-min(seedRawFile[which(seedRawFile[,1]%in%RT2_Standards),6])\n      for(Standard in RT2_Standards){\n        seedRawFile[,paste(Standard,\"RT2\",sep=\"_\")]<-(seedRawFile[,6]-seedRawFile[grep(Standard,seedRawFile[,1],perl = T),6])/RT2_Length\n      }\n    }\n\n    #Parse seed file metabolite spectra\n    currentRawFileSplit<-split(seedRawFile,1:nrow(seedRawFile))\n    SeedspectraSplit<-lapply(currentRawFileSplit, function(a) strsplit(a[[4]],\" \"))\n    SeedspectraSplit<-lapply(SeedspectraSplit, function(b) lapply(b, function(c) strsplit(c,\":\")))\n    SeedspectraSplit<-lapply(SeedspectraSplit, function(d) t(matrix(unlist(d),nrow=2)))\n    SeedspectraSplit<-lapply(SeedspectraSplit, function(d) d[order(d[,1]),])\n    SeedspectraSplit<-lapply(SeedspectraSplit, function(d) d[which(!d[,1]%in%commonIons),])\n    SeedspectraSplit<-lapply(SeedspectraSplit, function(d) apply(d,2,as.numeric))\n\n    #Establish alignment matrix\n    FinalMatrix<-matrix(nrow=nrow(seedRawFile),ncol=length(inputFileList))\n    row.names(FinalMatrix)<-seedRawFile[,1]\n    colnames(FinalMatrix)<-inputFileList\n    FinalMatrix[,inputFileList[seedFile]]<-seedRawFile[,3]\n\n    #Establish emptly list to store incongruent quant matches if using quantMethod \"U\" or \"A\"\n    MissingQMList<-list()\n    #Establish empty list to store similarity score matrices for each file\n    SimCutoffs<-list()\n    #Establish empty list to store parsed files\n    RawFileList<-list()\n    #Create empty list for missing retention indices\n    MissingRTIndices<-list()\n\n    #Loop through non seed files\n    message(\"Computing pairwise alignments\")\n    for(File in inputFileList[-seed]){\n\n      #Read in file\n      currentRawFile<-read.table(File, sep=\"\\t\", fill=T, quote=\"\",strip.white = T, stringsAsFactors = F,header=T)\n      currentRawFile[,4]<-as.character(currentRawFile[,4])\n      currentRawFile<-currentRawFile[which(!is.na(currentRawFile[,3])&nchar(currentRawFile[,4])!=0),]\n      currentRawFile[,2]<-as.character(currentRawFile[,2])\n\n      #Parse retention times\n      RTSplit<-data.frame(strsplit(currentRawFile[,2], \" , \"), stringsAsFactors = F)\n      RTSplit[1,]<-gsub(\"\\\"\", \"\", RTSplit[1,])\n      RTSplit[2,]<-gsub(\"\\\"\", \"\", RTSplit[2,])\n      currentRawFile[,\"RT1\"]<-as.numeric(t(RTSplit[1,]))\n      currentRawFile[,\"RT2\"]<-as.numeric(t(RTSplit[2,]))\n\n      #Index metabolites by RT1 standards\n      if(length(RT1_Standards)>0){\n        #Check if all RT1 standards are present\n        if(sum(RT1_Standards%in%currentRawFile[,1])!=length(RT1_Standards)){\n          MissingRTIndices[[File]]<-RT1_Standards[which(!RT1_Standards%in%currentRawFile[,1])]\n          next\n        }\n        #Index each metabolite by RT1 standards\n        RT1_Length<-max(currentRawFile[which(currentRawFile[,1]%in%RT1_Standards),6])-min(currentRawFile[which(currentRawFile[,1]%in%RT1_Standards),6])\n        for(Standard in RT1_Standards){\n          currentRawFile[,paste(Standard,\"RT1\",sep=\"_\")]<-(currentRawFile[,6]-currentRawFile[grep(Standard,currentRawFile[,1],perl = T),6])/RT1_Length\n        }\n      }\n\n      #Index metabolites by RT2 standards\n      if(length(RT2_Standards)>0){\n        #Check if all RT2 standards are present\n        if(sum(RT2_Standards%in%currentRawFile[,1])!=length(RT2_Standards)){\n          MissingRTIndices[[File]]<-RT2_Standards[which(!RT2_Standards%in%currentRawFile[,1])]\n          next\n        }\n        #Index each metabolite by RT2 standards\n        RT2_Length<-max(seedRawFile[which(seedRawFile[,1]%in%RT2_Standards),6])-min(seedRawFile[which(seedRawFile[,1]%in%RT2_Standards),6])\n        for(Standard in RT2_Standards){\n          seedRawFile[,paste(Standard,\"RT2\",sep=\"_\")]<-(seedRawFile[,6]-seedRawFile[grep(Standard,seedRawFile[,1],perl = T),6])/RT2_Length\n        }\n      }\n\n      #Parse metabolite spectra\n      currentRawFileSplit<-split(currentRawFile,1:nrow(currentRawFile))\n      spectraSplit<-lapply(currentRawFileSplit, function(a) strsplit(a[[4]],\" \"))\n      spectraSplit<-lapply(spectraSplit, function(b) lapply(b, function(c) strsplit(c,\":\")))\n      spectraSplit<-lapply(spectraSplit, function(d) t(matrix(unlist(d),nrow=2)))\n      spectraSplit<-lapply(spectraSplit, function(d) d[order(d[,1]),])\n      spectraSplit<-lapply(spectraSplit, function(d) d[which(!d[,1]%in%commonIons),])\n      spectraSplit<-lapply(spectraSplit, function(d) apply(d,2,as.numeric))\n\n      #Calculate pairwise metabolite similarity scores for each current file metabolite with seed file metabolites\n      SimilarityScores<-mclapply(spectraSplit, function(e) lapply(SeedspectraSplit, function(d) ((e[,2]%*%d[,2])/(sqrt(sum(e[,2]*e[,2]))*sqrt(sum(d[,2]*d[,2]))))*100), mc.cores=numCores)\n      SimilarityMatrix<-matrix(unlist(SimilarityScores), nrow=nrow(seedRawFile))\n\n      #Calculate pairwise RT penalties for each current file metabolite and seed file metabolites\n      RT1Index<-matrix(unlist(lapply(currentRawFile[,6],function(x) abs(x-seedRawFile[,6])*RT1Penalty)),nrow=nrow(seedRawFile))\n      RT2Index<-matrix(unlist(lapply(currentRawFile[,7],function(x) abs(x-seedRawFile[,7])*RT2Penalty)),nrow=nrow(seedRawFile))\n\n      #Use RT indices to calculate RT penalties if necessary\n      if(length(RT1_Standards)>0){\n        #Compute list of metabolite to RT1 standard differences between current file and seed file for each metabolite\n        RT1Index<-list()\n        for(Standard in RT1_Standards){\n          RT1Index[[Standard]]<-matrix(unlist(lapply(currentRawFile[,paste(Standard,\"RT1\",sep=\"_\")],function(x) abs(x-seedRawFile[,paste(Standard,\"RT1\",sep=\"_\")])*(RT1Penalty/length(RT1_Standards)))),nrow=nrow(seedRawFile))*RT1_Length\n        }\n        #Sum all relative standard differences into a final score\n        RT1Index<-Reduce(\"+\",RT1Index)\n      }\n      if(length(RT2_Standards)>0){\n        #Compute list of metabolite to RT2 standard differences between current file and seed file for each metabolite\n        RT2Index<-list()\n        for(Standard in RT2_Standards){\n          RT2Index[[Standard]]<-matrix(unlist(lapply(currentRawFile[,paste(Standard,\"RT2\",sep=\"_\")],function(x) abs(x-seedRawFile[,paste(Standard,\"RT2\",sep=\"_\")])*(RT2Penalty/length(RT2_Standards)))),nrow=nrow(seedRawFile))*RT2_Length\n        }\n        #Sum all relative standard differences into a final score\n        RT2Index<-Reduce(\"+\",RT2Index)\n      }\n\n      #Subtract final retention time penalties and store similarity scores in SimCutoffs\n      SimCutoffs[[File]]<-SimilarityMatrix-RT1Index-RT2Index\n      #Store parsed raw file in RawFileList\n      RawFileList[[File]]<-currentRawFile\n    }\n\n    #Error if missing RT indices are present\n    if(length(MissingRTIndices)>0){\n      message(\"Error: Missing RT indices detected. See output list\")\n      return(MissingRTIndices)\n      break\n    }\n\n    #Calculate optimal similarity score cutoff if desired\n    if(autoTuneMatchStringency==TRUE){\n      message(\"Computing peak similarity threshold\")\n      SimScores<-mclapply(SimCutoffs, function(y) unlist(lapply(1:100,function(x) sum(rowSums(y>x)>0)/(sum(y>x)^0.5))),mc.cores = numCores)\n      SimScores<-matrix(unlist(SimScores),ncol=length(SimScores))\n      similarityCutoff<-which.max(rowSums(SimScores))\n    }\n\n    #Loop back through input files and find matches above similarityCutoff threshold\n    for(File in inputFileList[-seed]){\n      currentRawFile<-RawFileList[[File]]\n\n      #Find best matches and mate pairs for each metabolite and remove inferior matches if metabolite is matched twice\n      MatchScores<-apply(SimCutoffs[[File]],2,function(x) max(x,na.rm=T))\n      Mates<-apply(SimCutoffs[[File]],2,function(x) which.max(x))\n      names(MatchScores)<-1:length(MatchScores)\n      names(Mates)<-1:length(Mates)\n      Mates<-Mates[order(-MatchScores)]\n      MatchScores<-MatchScores[order(-MatchScores)]\n      MatchScores[which(duplicated(Mates))]<-NA\n      Mates<-Mates[order(as.numeric(names(Mates)))]\n      MatchScores<-MatchScores[order(as.numeric(names(MatchScores)))]\n\n      if(quantMethod==\"U\"){\n        #Find quant masses for each match pair\n        MatchedSeedQMs<- seedRawFile[,5][Mates[which(MatchScores>=similarityCutoff)]]\n        currentFileQMs<- currentRawFile[which(MatchScores>=similarityCutoff),5]\n        #Add incongruent quant mass info to MissingQMList for output\n        MissingQMList[[File]]<-cbind(File,which(MatchScores>=similarityCutoff),currentFileQMs,inputFileList[seedFile],Mates[which(MatchScores>=similarityCutoff)],MatchedSeedQMs)[which(currentFileQMs!=MatchedSeedQMs),]\n        #Convert areas proportionally for incongruent quant masses\n        currentFileAreas<- currentRawFile[which(MatchScores>=similarityCutoff),3]\n        currentFileSpectra<- spectraSplit[which(MatchScores>=similarityCutoff)]\n        MatchedSeedSpectra<- SeedspectraSplit[Mates[which(MatchScores>=similarityCutoff)]]\n        ConvNumerator<-unlist(lapply(1:length(currentFileQMs), function(x) currentFileSpectra[[x]][which(currentFileSpectra[[x]][,1]==currentFileQMs[x]),2]))\n        ConvDenominator<-unlist(lapply(1:length(currentFileQMs), function(x) currentFileSpectra[[x]][which(currentFileSpectra[[x]][,1]==MatchedSeedQMs[x]),2]))\n        ConvDenominator[which(ConvDenominator==0)]<-NA\n        #Add matched peaks to final alignment matrix\n        FinalMatrix[Mates[which(MatchScores>=similarityCutoff)],File]<-currentFileAreas*(ConvNumerator/ConvDenominator)\n      }\n\n      if(quantMethod==\"A\"){\n        #Make function to parse apexing masses and test whether 50% are in common with seed file\n        TestQMOverlap<-function(x){\n          SeedQMs<- strsplit(x[1],\"\\\\+\")\n          FileQMs<- strsplit(x[2],\"\\\\+\")\n          sum(unlist(SeedQMs)%in%unlist(FileQMs))/min(length(unlist(SeedQMs)),length(unlist(FileQMs)))<0.5\n        }\n        #Test apexing mass overlap for each metabolite match\n        MatchedSeedQMs<- seedRawFile[,5][Mates[which(MatchScores>=similarityCutoff)]]\n        currentFileQMs<- currentRawFile[which(MatchScores>=similarityCutoff),5]\n        QM_Bind<-cbind(MatchedSeedQMs,currentFileQMs)\n        QM_Match<-apply(QM_Bind, 1, function(x) TestQMOverlap(x))\n        #Add incongruent apexing masses to MissingQMList for output\n        MissingQMList[[File]]<-cbind(File,which(MatchScores>=similarityCutoff),currentFileQMs,inputFileList[seedFile],Mates[which(MatchScores>=similarityCutoff)],MatchedSeedQMs)[which(QM_Match==TRUE),]\n        #Add matched peaks to final alignment matrix\n        FinalMatrix[Mates[which(MatchScores>=similarityCutoff)],File]<-currentRawFile[which(MatchScores>=similarityCutoff),3]\n      }\n\n      if(quantMethod==\"T\"){\n        #Add newly aligned peaks to alignment matrix\n        FinalMatrix[Mates[which(MatchScores>=similarityCutoff)],File]<-currentRawFile[which(MatchScores>=similarityCutoff),3]\n      }\n\n      #Find metabolites in current file sufficiently dissimilar to add to alignment matrix\n      toAdd<-matrix(ncol=length(inputFileList),nrow=length(which(MatchScores<disimilarityCutoff)))\n      colnames(toAdd)<-inputFileList\n      row.names(toAdd)<- currentRawFile[which(MatchScores<disimilarityCutoff),1]\n      toAdd[,File]<-currentRawFile[which(MatchScores<disimilarityCutoff),3]\n      FinalMatrix<-rbind(FinalMatrix,toAdd)\n      #Add new metabolite spectras to seed file spectra list\n      seedRawFile<-rbind(seedRawFile,currentRawFile[which(MatchScores<disimilarityCutoff),])\n      if(length(which(MatchScores<disimilarityCutoff))>0){\n        SeedspectraSplit[(length(SeedspectraSplit)+1):(length(SeedspectraSplit)+length(which(MatchScores<disimilarityCutoff)))]<- spectraSplit[which(MatchScores<disimilarityCutoff)]\n      }\n    }\n\n    #Filter final alignment matrix to only peaks passing the missing value limit\n    seedRawFile<-seedRawFile[which(rowSums(is.na(FinalMatrix))<=round(length(inputFileList)*(1-missingValueLimit))),]\n    FinalMatrix<-FinalMatrix[which(rowSums(is.na(FinalMatrix))<=round(length(inputFileList)*(1-missingValueLimit))),]\n\n    #Compute relaxed similarity cutoff with missingPeakFinderSimilarityLax\n    similarityCutoff<-similarityCutoff*missingPeakFinderSimilarityLax\n\n    message(\"Searching for missing peaks\")\n    #Loop through each file again and check for matches in high probability missing metabolites meeting relaxed similarity cutoff\n    for(File in inputFileList){\n\n      #read in file\n      currentRawFile<-read.table(File, sep=\"\\t\", fill=T, quote=\"\",strip.white = T, stringsAsFactors = F, header=T)\n      currentRawFile[,4]<-as.character(currentRawFile[,4])\n      currentRawFile<-currentRawFile[which(!is.na(currentRawFile[,3])&nchar(currentRawFile[,4])!=0),]\n      currentRawFile[,2]<-as.character(currentRawFile[,2])\n\n      #Parse retention times\n      RTSplit<-data.frame(strsplit(currentRawFile[,2], \" , \"), stringsAsFactors = F)\n      RTSplit[1,]<-gsub(\"\\\"\", \"\", RTSplit[1,])\n      RTSplit[2,]<-gsub(\"\\\"\", \"\", RTSplit[2,])\n      currentRawFile[,\"RT1\"]<-as.numeric(t(RTSplit[1,]))\n      currentRawFile[,\"RT2\"]<-as.numeric(t(RTSplit[2,]))\n\n      #Find peaks with missing values\n      MissingPeaks<-which(is.na(FinalMatrix[,File]))\n      if(length(MissingPeaks)>0){\n\n        #Calculate RT1 standard indices\n        if(length(RT1_Standards)>0){\n          RT1_Length<-max(currentRawFile[which(currentRawFile[,1]%in%RT1_Standards),6])-min(currentRawFile[which(currentRawFile[,1]%in%RT1_Standards),6])\n          for(Standard in RT1_Standards){\n            currentRawFile[,paste(Standard,\"RT1\",sep=\"_\")]<-(currentRawFile[,6]-currentRawFile[grep(Standard,currentRawFile[,1],perl = T),6])/RT1_Length\n          }\n        }\n\n        #Calculate RT2 standard indices\n        if(length(RT2_Standards)>0){\n          RT2_Length<-max(seedRawFile[which(seedRawFile[,1]%in%RT2_Standards),6])-min(seedRawFile[which(seedRawFile[,1]%in%RT2_Standards),6])\n          for(Standard in RT2_Standards){\n            seedRawFile[,paste(Standard,\"RT2\",sep=\"_\")]<-(seedRawFile[,6]-seedRawFile[grep(Standard,seedRawFile[,1],perl = T),6])/RT2_Length\n          }\n        }\n\n        #Parse metabolite spectra\n        currentRawFileSplit<-split(currentRawFile,1:nrow(currentRawFile))\n        spectraSplit<-lapply(currentRawFileSplit, function(a) strsplit(a[[4]],\" \"))\n        spectraSplit<-lapply(spectraSplit, function(b) lapply(b, function(c) strsplit(c,\":\")))\n        spectraSplit<-lapply(spectraSplit, function(d) t(matrix(unlist(d),nrow=2)))\n        spectraSplit<-lapply(spectraSplit, function(d) d[order(d[,1]),])\n        spectraSplit<-lapply(spectraSplit, function(d) d[which(!d[,1]%in%commonIons),])\n        spectraSplit<-lapply(spectraSplit, function(d) apply(d,2,as.numeric))\n\n        #Compute pairwise similarity scores\n        SimilarityScores<-mclapply(spectraSplit, function(e) lapply(SeedspectraSplit[MissingPeaks], function(d) ((e[,2]%*%d[,2])/(sqrt(sum(e[,2]*e[,2]))*sqrt(sum(d[,2]*d[,2]))))*100), mc.cores=numCores)\n        SimilarityMatrix<-matrix(unlist(SimilarityScores), nrow=length(MissingPeaks))\n\n        #Compute RT differences\n        RT1Index<-matrix(unlist(lapply(currentRawFile[,6],function(x) abs(x-seedRawFile[MissingPeaks,6])*RT1Penalty)),nrow=nrow(seedRawFile[MissingPeaks,]))\n        RT2Index<-matrix(unlist(lapply(currentRawFile[,7],function(x) abs(x-seedRawFile[MissingPeaks,7])*RT2Penalty)),nrow=nrow(seedRawFile[MissingPeaks,]))\n\n        #Use RT indices to calculate RT differences\n        if(length(RT1_Standards)>0){\n          RT1Index<-list()\n          for(Standard in RT1_Standards){\n            RT1Index[[Standard]]<-matrix(unlist(lapply(currentRawFile[,paste(Standard,\"RT1\",sep=\"_\")],function(x) abs(x-seedRawFile[MissingPeaks,paste(Standard,\"RT1\",sep=\"_\")])*(RT1Penalty/length(RT1_Standards)))),nrow=nrow(seedRawFile[MissingPeaks,]))*RT1_Length\n          }\n          RT1Index<-Reduce(\"+\",RT1Index)\n        }\n        if(length(RT2_Standards)>0){\n          RT2Index<-list()\n          for(Standard in RT2_Standards){\n            RT2Index[[Standard]]<-matrix(unlist(lapply(currentRawFile[,paste(Standard,\"RT2\",sep=\"_\")],function(x) abs(x-seedRawFile[,paste(Standard,\"RT2\",sep=\"_\")])*(RT2Penalty/length(RT2_Standards)))),nrow=nrow(seedRawFile))*RT2_Length\n          }\n          RT2Index<-Reduce(\"+\",RT2Index)\n        }\n\n        #Subtract RT penalty from similarity scores\n        SimilarityMatrix<-SimilarityMatrix-RT1Index-RT2Index\n\n        #Find top matches for each metabolite and remove duplicates if a metabolite matches multiple times\n        MatchScores<-apply(SimilarityMatrix,2,function(x) max(x,na.rm=T))\n        Mates<-apply(SimilarityMatrix,2,function(x) which.max(x))\n        names(MatchScores)<-1:length(MatchScores)\n        names(Mates)<-1:length(Mates)\n        Mates<-Mates[order(-MatchScores)]\n        MatchScores<-MatchScores[order(-MatchScores)]\n        MatchScores[which(duplicated(Mates))]<-NA\n        Mates<-Mates[order(as.numeric(names(Mates)))]\n        MatchScores<-MatchScores[order(as.numeric(names(MatchScores)))]\n        Mates<-MissingPeaks[Mates]\n\n        #If matches are greater than relaxed simlarity cutoff add to final alignment table\n        if(length(which(MatchScores>=similarityCutoff))>0){\n          if(quantMethod==\"U\"){\n            #Find quant masses for each match pair\n            MatchedSeedQMs<- seedRawFile[,5][Mates[which(MatchScores>=similarityCutoff)]]\n            currentFileQMs<- currentRawFile[which(MatchScores>=similarityCutoff),5]\n            #Add incongruent quant mass info to MissingQMList for output\n            MissingQMList[[paste0(File,\"_MPF\")]]<-cbind(File,which(MatchScores>=similarityCutoff),currentFileQMs,inputFileList[seedFile],Mates[which(MatchScores>=similarityCutoff)],MatchedSeedQMs)[which(currentFileQMs!=MatchedSeedQMs),]\n            #Convert areas proportionally for incongruent quant masses\n            currentFileAreas<- currentRawFile[which(MatchScores>=similarityCutoff),3]\n            currentFileSpectra<- spectraSplit[which(MatchScores>=similarityCutoff)]\n            MatchedSeedSpectra<- SeedspectraSplit[Mates[which(MatchScores>=similarityCutoff)]]\n            ConvNumerator<-unlist(lapply(1:length(currentFileQMs), function(x) currentFileSpectra[[x]][which(currentFileSpectra[[x]][,1]==currentFileQMs[x]),2]))\n            ConvDenominator<-unlist(lapply(1:length(currentFileQMs), function(x) currentFileSpectra[[x]][which(currentFileSpectra[[x]][,1]==MatchedSeedQMs[x]),2]))\n            ConvDenominator[which(ConvDenominator==0)]<-NA\n            #Add matched peaks to final alignment matrix\n            FinalMatrix[Mates[which(MatchScores>=similarityCutoff)],File]<-currentFileAreas*(ConvNumerator/ConvDenominator)\n          }\n          if(quantMethod==\"A\"){\n            #Make function to parse apexing masses and test whether 50% are in common with seed file\n            TestQMOverlap<-function(x){\n              SeedQMs<- strsplit(x[1],\"\\\\+\")\n              FileQMs<- strsplit(x[2],\"\\\\+\")\n              return(sum(unlist(SeedQMs)%in%unlist(FileQMs))/min(length(unlist(SeedQMs)),length(unlist(FileQMs)))<0.5)\n            }\n            #Test apexing mass overlap for each metabolite match\n            MatchedSeedQMs<- seedRawFile[,5][Mates[which(MatchScores>=similarityCutoff)]]\n            currentFileQMs<- currentRawFile[which(MatchScores>=similarityCutoff),5]\n            QM_Bind<-cbind(MatchedSeedQMs,currentFileQMs)\n            QM_Match<-apply(QM_Bind, 1, function(x) TestQMOverlap(x))\n            #Add incongruent apexing masses to MissingQMList for output\n            MissingQMList[[paste0(File,\"_MPF\")]]<-cbind(File,which(MatchScores>=similarityCutoff),currentFileQMs,inputFileList[seedFile],Mates[which(MatchScores>=similarityCutoff)],MatchedSeedQMs)[which(QM_Match==TRUE),]\n            #Add matched peaks to final alignment matrix\n            FinalMatrix[Mates[which(MatchScores>=similarityCutoff)],File]<-currentRawFile[which(MatchScores>=similarityCutoff),3]\n          }\n          if(quantMethod==\"T\"){\n            #Add matched peaks to final alignment matrix\n            FinalMatrix[Mates[which(MatchScores>=similarityCutoff)],File]<-currentRawFile[which(MatchScores>=similarityCutoff),3]\n          }\n        }\n      }\n    }\n    #Make MissingQMList into dataframe for output\n    MissingQMFrame<-do.call(rbind,MissingQMList)\n    AlignmentTableList[[as.character(seed)]]<-FinalMatrix\n  }\n\n  #If only one seed file is provided just output alignment matrix\n  if(length(seedFile)==1){\n    FinalMatrix<-AlignmentTableList[[1]]\n  }\n\n  #If multiple seed files provided find peaks with >50% overlap across all seed files\n  if(length(seedFile)>1){\n\n    #\n    ConsensusPeaks<-list()\n    ConsensusMatches<-list()\n    for(i in 1:(length(AlignmentTableList)-1)){\n      Overlaps<-apply(AlignmentTableList[[i]], 1, function(y) apply(AlignmentTableList[[length(AlignmentTableList)]], 1, function(x) sum(x%in%y, na.rm = T)))\n      Indexes<-arrayInd(which(Overlaps>12), dim(Overlaps))\n      row.names(Indexes)<-Indexes[,1]\n      ConsensusPeaks[[i]]<-Indexes[,1]\n      ConsensusMatches[[i]]<-Indexes\n    }\n\n    ConsensusPeaks<-Reduce(intersect, ConsensusPeaks)\n\n    AlignmentTableListFilt<-AlignmentTableList\n    for(i in 1:(length(AlignmentTableList)-1)){\n      AlignmentTableListFilt[[i]]<-AlignmentTableListFilt[[i]][ConsensusMatches[[i]][as.character(ConsensusPeaks),2],inputFileList]\n    }\n    AlignmentTableListFilt[[length(AlignmentTableListFilt)]]<-AlignmentTableListFilt[[length(AlignmentTableListFilt)]][ConsensusPeaks,inputFileList]\n\n    AlignVector<-data.frame(lapply(AlignmentTableListFilt, as.vector))\n    FinalMatrix<-matrix(apply(AlignVector,1,function(x) median(x, na.rm=T)), nrow = length(ConsensusPeaks))\n    colnames(FinalMatrix)<-inputFileList\n    row.names(FinalMatrix)<- row.names(AlignmentTableListFilt[[length(AlignmentTableListFilt)]])\n  }\n  #Add metabolite IDs if standardLibrary is used\n  if(!is.null(standardLibrary)){\n    message(\"Matching peaks to standard library\")\n\n    #Parse seed file spectras\n    peakSplit<-split(seedRawFile,1:nrow(seedRawFile))\n    peakSpectraSplit<-lapply(peakSplit, function(a) strsplit(a[[4]],\" \"))\n    peakSpectraSplit<-lapply(peakSpectraSplit, function(b) lapply(b, function(c) strsplit(c,\":\")))\n    peakSpectraSplit<-lapply(peakSpectraSplit, function(d) t(matrix(unlist(d),nrow=2)))\n    peakSpectraSplit<-lapply(peakSpectraSplit, function(d) d[order(d[,1]),])\n    peakSpectraSplit<-lapply(peakSpectraSplit, function(d) d[which(!d[,1]%in%commonIons),])\n    peakSpectraSplit<-lapply(peakSpectraSplit, function(d) apply(d,2,as.numeric))\n\n    #Parse standard library spectras\n    standardSplit<-split(standardLibrary,1:nrow(standardLibrary))\n    standardSpectraSplit<-lapply(standardSplit, function(a) strsplit(a[[3]],\" \"))\n    standardSpectraSplit<-lapply(standardSpectraSplit, function(b) lapply(b, function(c) strsplit(c,\":\")))\n    standardSpectraSplit<-lapply(standardSpectraSplit, function(d) t(matrix(unlist(d),nrow=2)))\n    standardSpectraSplit<-lapply(standardSpectraSplit, function(d) d[order(d[,1]),])\n    standardSpectraSplit<-lapply(standardSpectraSplit, function(d) d[which(!d[,1]%in%commonIons),])\n    standardSpectraSplit<-lapply(standardSpectraSplit, function(d) apply(d,2,as.numeric))\n\n    #Calculate pairwise similarity scores\n    SimilarityScores<-mclapply(peakSpectraSplit, function(e) lapply(standardSpectraSplit, function(d) ((e[,2]%*%d[,2])/(sqrt(sum(e[,2]*e[,2]))*sqrt(sum(d[,2]*d[,2]))))*100), mc.cores=numCores)\n    SimilarityMatrix<-matrix(unlist(SimilarityScores), nrow=length(standardSpectraSplit))\n\n    #Compute RT differences\n    RT1Index<-matrix(unlist(lapply(seedRawFile[,6],function(x) abs(x-standardLibrary[,4])*RT1Penalty)),nrow=nrow(standardLibrary))\n    RT2Index<-matrix(unlist(lapply(seedRawFile[,7],function(x) abs(x-standardLibrary[,5])*RT2Penalty)),nrow=nrow(standardLibrary))\n\n    #Use RT indexes to compute RT differences\n    if(length(RT1_Standards)>0){\n      RT1Index<-list()\n      for(Standard in RT1_Standards){\n        RT1Index[[Standard]]<-matrix(unlist(lapply(seedRawFile[,paste(Standard,\"RT1\",sep=\"_\")],function(x) abs(x-standardLibrary[,paste(Standard,\"RT1\",sep=\"_\")])*(RT1Penalty/length(RT1_Standards)))),nrow=nrow(standardLibrary))*RT1_Length\n      }\n      RT1Index<-Reduce(\"+\",RT1Index)\n    }\n    if(length(RT2_Standards)>0){\n      RT2Index<-list()\n      for(Standard in RT2_Standards){\n        RT2Index[[Standard]]<-matrix(unlist(lapply(currentRawFile[,paste(Standard,\"RT2\",sep=\"_\")],function(x) abs(x-seedRawFile[,paste(Standard,\"RT2\",sep=\"_\")])*(RT2Penalty/length(RT2_Standards)))),nrow=nrow(seedRawFile))*RT2_Length\n      }\n      RT2Index<-Reduce(\"+\",RT2Index)\n    }\n\n    #Subtract RT penalties from Similarity Scores\n    SimilarityMatrix<-SimilarityMatrix-RT1Index-RT2Index\n    row.names(SimilarityMatrix)<-standardLibrary[,1]\n\n    #Append top three ID matches to each metabolite and scores to seedRaw for output\n    seedRawFile<-cbind(t(apply(SimilarityMatrix,2,function(x) paste(names(x[order(-x)])[1:3],round(x[order(-x)][1:3],2),sep=\"_\"))),seedRawFile)\n  }\n  returnList<-list(FinalMatrix, seedRawFile, MissingQMFrame)\n  names(returnList)<-c(\"AlignmentMatrix\",\"MetaboliteInfo\",\"UnmatchedQuantMasses\")\n  return(returnList)\n}\n",
    "created" : 1488082030540.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3625899232",
    "id" : "2C291EC3",
    "lastKnownWriteTime" : 1488435288,
    "last_content_update" : 1488435288342,
    "path" : "~/Desktop/R2DGC/R/ConsensusAlign.R",
    "project_path" : "R/ConsensusAlign.R",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}
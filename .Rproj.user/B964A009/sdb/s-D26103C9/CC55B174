{
    "collab_server" : "",
    "contents" : "#' This function is an optional pre-prossessing step before running consensus align to identify peaks that likely need to be combined prior to running consensus align and will perform a rough combine of these peaks depending on the quant method as an output.\n\n#' @param inputFileList A character vector with full file paths to chromatof files for processing.\n#' @param RT1Penalty A numeric indicating penalty used for first retention time differences. Defaults to 1\n#' @param RT2Penalty A numeric indicating penalty used for second retention time differences. Defaults to 100\n#' @param similarityCutoff A numeric indicating the similarity threshold (max=100) to use for declaring peaks to combine. Defaults to 95\n#' @param numCores Number of cores used to parallelize alignment. See parallel package for details. Defaults to 1\n#' @param commonIons A numeric vector of ions to exclude from alignment scores. Can provide first column of output from FindProblemIons function.\n#' @param quantMethod Character indicating the quant method used in computing peak areas on chromatof. Accepts \"U\", \"T\", or \"A\" for unique mass, total ion chromatograph or apexing mass. Defaults to \"T\". If \"T\" or \"A\", peaks meeting similarity thresholds will simply be summed. If \"U\", peaks with the same unique mass with be summed and a proportional conversion will be used before combining peaks with different unique masses.\n#' @param outputFiles A boolean indicating if putative peak combinations should be outputted. Will be present at the same path as the input file with _Processed.txt appended to the end.\n\n#' @import parallel\n#' @export\n#' @return Returns a data frame with peaks recommended to be combined. If outputFiles is TRUE, peaks returned will be combined and new sample files will be written to the original directory with \"_Processed.txt\" added to the file name.\n#' @examples\n#' PrecompressFiles(inputFileList=system.file(\"extdata\", \"SampleA.txt\", package=\"R2DGC\"))\n\nPrecompressFiles<-function(inputFileList, RT1Penalty=1, RT2Penalty=10,similarityCutoff=95, numCores=1, commonIons=c(), quantMethod=\"T\", outputFiles=F){\n\n  #Create empty list to store processed dataframes for output\n  processedFileList<-list()\n\n  #Create empty list to store record of all peaks that should be combined\n  combinedList<-list()\n\n\n  for(File in inputFileList){\n\n    #Read in file\n    currentRawFile<-read.table(File, sep=\"\\t\", fill=T, quote=\"\",strip.white = T, stringsAsFactors = F,header=T)\n    currentRawFile[,4]<-as.character(currentRawFile[,4])\n    currentRawFile<-currentRawFile[which(!is.na(currentRawFile[,3])&nchar(currentRawFile[,4])!=0),]\n    currentRawFile[,2]<-as.character(currentRawFile[,2])\n\n    #Parse retention times\n    RTSplit<-data.frame(strsplit(currentRawFile[,2], \" , \"), stringsAsFactors = F)\n    RTSplit[1,]<-gsub(\"\\\"\", \"\", RTSplit[1,])\n    RTSplit[2,]<-gsub(\"\\\"\", \"\", RTSplit[2,])\n    currentRawFile[,\"RT1\"]<-as.numeric(t(RTSplit[1,]))\n    currentRawFile[,\"RT2\"]<-as.numeric(t(RTSplit[2,]))\n\n    #Remove identical metabolite rows\n    uniqueIndex<-data.frame(paste(currentRawFile[,1], currentRawFile[,2], currentRawFile[,3]))\n    currentRawFile<-currentRawFile[which(!duplicated(uniqueIndex)),]\n    row.names(currentRawFile)<-c(1:nrow(currentRawFile))\n\n    #Parse metabolite spectra into a list\n    currentRawFileSplit<-split(currentRawFile,1:nrow(currentRawFile))\n    spectraSplit<-lapply(currentRawFileSplit, function(a) strsplit(a[[4]],\" \"))\n    spectraSplit<-lapply(spectraSplit, function(b) lapply(b, function(c) strsplit(c,\":\")))\n    spectraSplit<-lapply(spectraSplit, function(d) t(matrix(unlist(d),nrow=2)))\n    spectraSplit<-lapply(spectraSplit, function(d) d[order(d[,1]),])\n    spectraSplit<-lapply(spectraSplit, function(d) d[which(!d[,1]%in%commonIons),])\n    spectraSplit<-lapply(spectraSplit, function(d) apply(d,2,as.numeric))\n\n    #Calculate pair wise similarity scores between all metabolite spectras\n    SimilarityScores<- parallel::mclapply(spectraSplit, function(e) lapply(spectraSplit, function(d) ((e[,2]%*%d[,2])/(sqrt(sum(e[,2]*e[,2]))*sqrt(sum(d[,2]*d[,2]))))*100), mc.cores=numCores)\n    SimilarityMatrix<-matrix(unlist(SimilarityScores), nrow=length(SimilarityScores))\n\n    #Subtract retention time difference penalties from similarity scores\n    RT1Index<-matrix(unlist(lapply(currentRawFile[,\"RT1\"],function(x) abs(x-currentRawFile[,\"RT1\"])*RT1Penalty)),nrow=length(SimilarityScores))\n    RT2Index<-matrix(unlist(lapply(currentRawFile[,\"RT2\"],function(x) abs(x-currentRawFile[,\"RT2\"])*RT2Penalty)),nrow=length(SimilarityScores))\n    SimilarityMatrix<-SimilarityMatrix-RT1Index-RT2Index\n    diag(SimilarityMatrix)<-0\n\n    #Find metabolites to with similarity scores greater than similarityCutoff to combine\n    MatchList<-apply(SimilarityMatrix,1,function(x) which(x>=similarityCutoff))\n\n    #Initialize number of times to loop through match list in case more than two peaks need to be combined\n    NumReps<-0\n    if(length(MatchList)>0){\n      NumReps<-max(unlist(lapply(MatchList, length)))-1\n\n      if(quantMethod==\"U\"){\n\n        #Find mates to combine\n        Mates<-lapply(MatchList,function(x) x[1])\n        BindingQMs<-currentRawFile[unlist(Mates[which(!is.na(Mates))]),5]\n        BindingAreas<-currentRawFile[unlist(Mates[which(!is.na(Mates))]),3]\n        BindingSpectra<-spectraSplit[unlist(Mates[which(!is.na(Mates))])]\n\n        #Find mate partner to combine\n        toBind<-currentRawFile[which(!is.na(Mates)),]\n        #Add peak info to combinedList to for output\n        combinedList[[File]]<-cbind(toBind,currentRawFile[unlist(Mates[which(!is.na(Mates))]),],File)\n        toBind[,\"Bound\"]<-rep(NA, nrow(toBind))\n        toBindQMs<-toBind[,5]\n        toBindSpectra<-spectraSplit[which(!is.na(Mates))]\n\n        #Perform proportional conversion to adjust peak areas with differing unique masses\n        ConvNumerator<-unlist(lapply(1:length(toBindQMs), function(x) toBindSpectra[[x]][which(toBindSpectra[[x]][,1]==toBindQMs[x]),2]))\n        ConvDenominator<-unlist(lapply(1:length(toBindQMs), function(x) toBindSpectra[[x]][which(toBindSpectra[[x]][,1]==BindingQMs[x]),2]))\n        ConvDenominator[which(ConvDenominator==0)]<-NA\n        toBind[,3]<-(toBind[,3]*(ConvNumerator/ConvDenominator))+BindingAreas\n\n        #Make sure only one combination (mate to partner) is included in output dataframe\n        toBind$Bound<-paste(toBind$Bound,apply(cbind(unlist(Mates[which(!is.na(Mates))]),which(!is.na(Mates))),1,min),sep=\"_\")\n        toBind<-toBind[which(!duplicated(toBind$Bound)),]\n\n        #Modify sample metabolite frame to include only combined peak\n        currentRawFile<-currentRawFile[which(is.na(Mates)),]\n        currentRawFile<-rbind(currentRawFile,toBind[,-ncol(toBind)])\n      }\n\n      if(quantMethod==\"A\"|quantMethod==\"T\"){\n\n        #Find mates to combine\n        Mates<-lapply(MatchList,function(x) x[1])\n        BindingAreas<-currentRawFile[unlist(Mates[which(!is.na(Mates))]),3]\n\n        #Find mates partners to combine\n        toBind<-currentRawFile[which(!is.na(Mates)),]\n        #Add peak info to combined list for output\n        combinedList[[File]]<-cbind(toBind,currentRawFile[unlist(Mates[which(!is.na(Mates))]),],File)\n        toBind[,\"Bound\"]<-rep(NA, nrow(toBind))\n\n        #Sum peak areas\n        toBind[,3]<-toBind[,3]+BindingAreas\n\n        #Ensure only one peak combination gets included in output\n        toBind$Bound<-paste(toBind$Bound,apply(cbind(unlist(Mates[which(!is.na(Mates))]),which(!is.na(Mates))),1,min),sep=\"_\")\n        toBind<-toBind[which(!duplicated(toBind$Bound)),]\n\n        #Update sample metabolite file to include on combined peak\n        currentRawFile<-currentRawFile[which(is.na(Mates)),]\n        currentRawFile<-rbind(currentRawFile,toBind[,-ncol(toBind)])\n      }\n    }\n\n    #If any metabolites had greater than two peaks to combine, loop through and make those combinations iteratively\n    if(NumReps>0){\n      for(Rep in 1:NumReps){\n\n        #Repeat similarity scores with combined peaks\n        row.names(currentRawFile)<-c(1:nrow(currentRawFile))\n        currentRawFileSplit<-split(currentRawFile,1:nrow(currentRawFile))\n        spectraSplit<-lapply(currentRawFileSplit,function(a) strsplit(a[[4]],\" \"))\n        spectraSplit<-lapply(spectraSplit, function(b) lapply(b, function(c) strsplit(c,\":\")))\n        spectraSplit<-lapply(spectraSplit, function(d) t(matrix(unlist(d),nrow=2)))\n        spectraSplit<-lapply(spectraSplit, function(d) d[order(d[,1]),])\n        spectraSplit<-lapply(spectraSplit, function(d) d[which(!d[,1]%in%commonIons),])\n        spectraSplit<-lapply(spectraSplit, function(d) apply(d,2,as.numeric))\n        SimilarityScores<- parallel::mclapply(spectraSplit, function(e) lapply(spectraSplit, function(d) ((e[,2]%*%d[,2])/(sqrt(sum(e[,2]*e[,2]))*sqrt(sum(d[,2]*d[,2]))))*100), mc.cores=numCores)\n        SimilarityMatrix<-matrix(unlist(SimilarityScores), nrow=length(SimilarityScores))\n        RT1Index<-matrix(unlist(lapply(currentRawFile[,\"RT1\"],function(x) abs(x-currentRawFile[,\"RT1\"])*RT1Penalty)),nrow=length(SimilarityScores))\n        RT2Index<-matrix(unlist(lapply(currentRawFile[,\"RT2\"],function(x) abs(x-currentRawFile[,\"RT2\"])*RT2Penalty)),nrow=length(SimilarityScores))\n        SimilarityMatrix<-SimilarityMatrix-RT1Index-RT2Index\n        diag(SimilarityMatrix)<-0\n\n        #Repeat peak combination if more combinations are necessary\n        MatchList<-apply(SimilarityMatrix,1,function(x) which(x>=similarityCutoff))\n        if(length(MatchList)>0){\n          if(quantMethod==\"U\"){\n            Mates<-lapply(MatchList,function(x) x[1])\n            BindingQMs<-currentRawFile[unlist(Mates[which(!is.na(Mates))]),5]\n            BindingAreas<-currentRawFile[unlist(Mates[which(!is.na(Mates))]),3]\n            BindingSpectra<-spectraSplit[unlist(Mates[which(!is.na(Mates))])]\n            toBind<-currentRawFile[which(!is.na(Mates)),]\n            combinedList[[File]]<-rbind(combinedList[[File]],cbind(toBind,currentRawFile[unlist(Mates[which(!is.na(Mates))]),],File))\n            toBind[,\"Bound\"]<-rep(NA, nrow(toBind))\n            toBindQMs<-toBind[,5]\n            toBindSpectra<-spectraSplit[which(!is.na(Mates))]\n            ConvNumerator<-unlist(lapply(1:length(toBindQMs), function(x) toBindSpectra[[x]][which(toBindSpectra[[x]][,1]==toBindQMs[x]),2]))\n            ConvDenominator<-unlist(lapply(1:length(toBindQMs), function(x) toBindSpectra[[x]][which(toBindSpectra[[x]][,1]==BindingQMs[x]),2]))\n            ConvDenominator[which(ConvDenominator==0)]<-NA\n            toBind[,3]<-toBind[,3]*(ConvNumerator/ConvDenominator)\n            toBind$Bound<-paste(toBind$Bound,apply(cbind(unlist(Mates[which(!is.na(Mates))]),which(!is.na(Mates))),1,min),sep=\"_\")\n            toBind<-toBind[which(!duplicated(toBind$Bound)),]\n            currentRawFile<-currentRawFile[which(is.na(Mates)),]\n            currentRawFile<-rbind(currentRawFile,toBind[,-ncol(toBind)])\n          }\n          if(quantMethod==\"A\"|quantMethod==\"T\"){\n            Mates<-lapply(MatchList,function(x) x[1])\n            BindingAreas<-currentRawFile[unlist(Mates[which(!is.na(Mates))]),3]\n            toBind<-currentRawFile[which(!is.na(Mates)),]\n            combinedList[[File]]<-rbind(combinedList[[File]],cbind(toBind,currentRawFile[unlist(Mates[which(!is.na(Mates))]),],File))\n            toBind[,\"Bound\"]<-rep(NA, nrow(toBind))\n            toBind[,3]<-toBind[,3]+BindingAreas\n            toBind$Bound<-paste(toBind$Bound,apply(cbind(unlist(Mates[which(!is.na(Mates))]),which(!is.na(Mates))),1,min),sep=\"_\")\n            toBind<-toBind[which(!duplicated(toBind$Bound)),]\n            currentRawFile<-currentRawFile[which(is.na(Mates)),]\n            currentRawFile<-rbind(currentRawFile,toBind[,-ncol(toBind)])\n          }\n        }\n      }\n    }\n\n    #Add processed file with putative peak area combinations to processedFileList for output\n    processedFileList[[File]]<-currentRawFile[,1:5]\n  }\n\n  #Make data frame with all combined peak pair info\n  combinedFrame<-do.call(rbind,combinedList)\n  if(length(combinedFrame)>0){\n    row.names(combinedFrame)<-1:nrow(combinedFrame)\n  }\n  #If outputFiles==TRUE, write processed files out to the input file directory\n  if(outputFiles==TRUE){\n    for(File in inputFileList){\n      write.table(processedFileList[[File]], paste0(substr(File,1,nchar(File)-4),\"_Processed.txt\"),sep=\"\\t\",quote=F,row.names=F)\n    }\n  }\n  return(combinedFrame)\n}\n",
    "created" : 1488079858854.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3465515793",
    "id" : "CC55B174",
    "lastKnownWriteTime" : 1488169147,
    "last_content_update" : 1488169147352,
    "path" : "~/Desktop/R2DGC/R/PrecompressFiles.R",
    "project_path" : "R/PrecompressFiles.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}